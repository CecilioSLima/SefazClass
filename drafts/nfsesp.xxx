/*
NFSE.PRG - NFS-e Gera Nota Fiscal de Servi‡o Eletronica
2016.04.29 VIA PROGRAMA WSOFT EMC
# nfse-sp-eduardo
NFSE SP eduardomc00
*/

#include "common.ch"
#include "hbclass.ch"
#include "inkey.ch"
#include "fileio.ch"
#include "directry.ch"

// #include "hbnfe.ch"
// #include "wsmode.ch"
// #include "wsnatop.ch"
// #include "wscalc_f.ch"
// #include "wsfile.ch"
// #include "wsecf.ch"
// #include "wsged.ch"

#define _MSXML2_DOMDOCUMENT                   "FALTA"
#define _MSXML2_MXDIGITALSIGNATURE            "FALTA"
#define _CAPICOM_MEMORY_STORE                 "FALTA"
#define _CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED   "FALTA"
#define _MSXML2_XMLSCHEMACACHE                "FALTA"
#define _MSXML2_SERVERXMLHTTP                 "FALTA"
#define GC_NFE_NS_CERTIF                      "FALTA"
#define _CAPICOM_CURRENT_USER_STORE           "FALTA"

// #include "dll.ch"


MEMVAR cArq, cAssinatura, cXml, lAbre, lFecha, oError, cXmlSig, PosIni, PosFim, NP, nResult, oResult
MEMVAR MI, E, nHandle, cRetXml, cUrlWs, cNameSpace, aRetorno, oDll, cRet

CLASS NFSE

   DATA oFuncoes  INIT hbNFeFuncoes()
   // DATA oCTe_GERAIS INIT oCTe_GERAIS()
   DATA ohbNFe
   DATA oSigner
   DATA Xml

   // Cabecalho
   DATA cab_CodCidade
   DATA cab_CPFCNPJRemetente
   DATA cab_RazaoSocialRemetente
   DATA cab_dtInicio
   DATA cab_dtFim
   DATA cab_QtdRPS
   DATA cab_ValorTotalServicos
   DATA cab_ValorTotalDeducoes
   DATA cab_Versao INIT 1
   DATA cab_MetodoEnvio INIT 'WS'
   DATA cab_VersaoComponente INIT '6.0004'

   // Rps
   DATA rps_InscricaoMunicipalPrestador
   DATA rps_RazaoSocialPrestador
   DATA rps_TipoRPS INIT 'RPS'
   DATA rps_SerieRPS INIT 'NF'
   DATA rps_NumeroRPS
   DATA rps_DataEmissaoRPS
   DATA rps_SituacaoRPS
   DATA rps_SerieRPSSubstituido
   DATA rps_NumeroRPSSubstituido
   DATA rps_NumeroNFSeSubstituida
   DATA rps_DataEmissaoNFSeSubstituida INIT Stod( "1900/01/01" )
   DATA rps_SeriePrestacao INIT '99'
   DATA rps_InscricaoMunicipalTomador
   DATA rps_CPFCNPJTomador
   DATA rps_RazaoSocialTomador
   DATA rps_DocTomadorEstrangeiro
   DATA rps_TipoLogradouroTomador
   DATA rps_LogradouroTomador
   DATA rps_NumeroEnderecoTomador
   DATA rps_ComplementoEnderecoTomador
   DATA rps_TipoBairroTomador
   DATA rps_BairroTomador
   DATA rps_CidadeTomador
   DATA rps_CidadeTomadorDescricao
   DATA rps_CEPTomador
   DATA rps_EmailTomador
   DATA rps_CodigoAtividade
   DATA rps_AliquotaAtividade
   DATA rps_TipoRecolhimento
   DATA rps_MunicipioPrestacao
   DATA rps_MunicipioPrestacaoDescricao
   DATA rps_Operacao
   DATA rps_Tributacao
   DATA rps_ValorPIS
   DATA rps_ValorCOFINS
   DATA rps_ValorINSS
   DATA rps_ValorIR
   DATA rps_ValorCSLL
   DATA rps_AliquotaPIS
   DATA rps_AliquotaCOFINS
   DATA rps_AliquotaINSS
   DATA rps_AliquotaIR
   DATA rps_AliquotaCSLL
   DATA rps_DescricaoRPS
   DATA rps_DDDPrestador
   DATA rps_TelefonePrestador
   DATA rps_DDDTomador
   DATA rps_TelefoneTomador
   DATA rps_MotCancelamento
   DATA rps_CPFCNPJIntermediario

   // V10.0.K1292
   DATA cValorCargaTributaria
   DATA cPercentualCargaTributaria
   // V10.0.K1292

   // Registros de Itens da RPS
   DATA Itens_DiscriminacaoServico
   DATA Itens_Quantidade
   DATA Itens_ValorUnitario
   DATA Itens_ValorTotal
   DATA Itens_Tributavel

   // Registro das Deducoes
   DATA Deducao_DeducaoPor
   DATA Deducao_TipoDeducao
   DATA Deducao_CPFCNPJReferencia
   DATA Deducao_NumeroNFReferencia
   DATA Deducao_ValorTotalReferencia
   DATA Deducao_PercentualDeduzir
   DATA Deducao_ValorDeduzir

   DATA numero_nota
   DATA codigo_verificacao
   DATA motivo

   METHOD Registro_Cabecalho()
   METHOD Registro_RPS()
   METHOD Registro_Itens_RPS( lABRE, lFECHA )
   METHOD Registro_Deducao_RPS( /* lABRE,lFECHA */ )
   METHOD Assina_XML()

   METHOD Finaliza_RPS()

   METHOD Gera_Chave_SHA1()
   METHOD Gera_Chave_SHA1_Cancelamento()
   METHOD LinkWebService( /* cServ */ )
   METHOD ComunicaWebService( cMETHOD )
   METHOD ctPegaCNCertificado()
   METHOD LeRetorno( cRET )
   METHOD CancelaNFSe()
   METHOD ValidaXML()

   ENDCLASS

METHOD Registro_Cabecalho() CLASS NFSE

   LOCAL aRETORNO := Hash()
   LOCAL cXML := '', cARQ
   LOCAL nHandle

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::cab_CodCidade = NIL .OR. ::cab_CodCidade <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar o código do município'
   ENDIF
   IF ::cab_CPFCNPJRemetente = NIL .OR. Empty( ::cab_CPFCNPJRemetente )
      aRETORNO[ 'MSG' ] := 'Favor informar o CPF / CNPJ do Remetente'
   ENDIF
   IF ::cab_RazaoSocialRemetente = NIL .OR. Empty( ::cab_RazaoSocialRemetente )
      aRETORNO[ 'MSG' ] := 'Favor informar a razão social do Remetente'
   ENDIF
   IF ::cab_dtInicio = NIL .OR. Day( ::cab_dtInicio ) <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar a data inicial da remessa'
   ENDIF
   IF ::cab_dtFim = NIL .OR. Day( ::cab_dtFim ) <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar a data final da remessa'
   ENDIF
   IF ::cab_ValorTotalServicos = NIL
      ::cab_ValorTotalServicos := 0
   ENDIF
   IF ::cab_ValorTotalDeducoes = NIL
      ::cab_ValorTotalDeducoes := 0
   ENDIF

   IF !Empty( aRETORNO[ 'MSG' ] )
      RETURN aRETORNO
   ENDIF

   cXML += '<PedidoEnvioLoteRPS xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://www.prefeitura.sp.gov.br/nfe">'

   cXML += '<Cabecalho Versao="1" xmlns="">'
   cXML +=   '<CPFCNPJRemetente><CNPJ>' + AllTrim( ::cab_CPFCNPJRemetente ) + '</CNPJ></CPFCNPJRemetente>'
   cXML +=   '<transacao>false</transacao>'
   cXML +=   '<dtInicio>' + DateXml( ::cab_dtInicio ) + '</dtInicio>'
   cXML +=   '<dtFim>' + DateXml( ::cab_dtFim ) + '</dtFim>'
   cXML +=   '<QtdRPS>' + AllTrim( Str( ::cab_QtdRPS ) ) + '</QtdRPS>'
   cXML +=   '<ValorTotalServicos>' + AllTrim( Str( ::cab_ValorTotalServicos ) ) + '</ValorTotalServicos>'
   cXML +=   '<ValorTotalDeducoes>' + AllTrim( Str( ::cab_ValorTotalDeducoes ) ) + '</ValorTotalDeducoes>'
   cXML += '</Cabecalho>'

   cARQ := ::ohbNFe:pastaEnvRes + '\NFSe' + AllTrim( ::cab_CPFCNPJRemetente ) + DToS( Date() ) + StrTran( Left( Time(), 8 ), ':' ) + '.xml'

   nHandle := FCreate( cARQ )
   FWrite( nHandle, cXML )
   FClose( nHandle )
   ::XML := cARQ
   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := cARQ
   aRETORNO[ 'MSG' ] := 'XML criado em ' + cARQ

   RETURN aRETORNO

METHOD Registro_RPS() CLASS NFSE

   LOCAL aRETORNO := Hash()
   LOCAL cXML := '' // , cARQ :=''
   LOCAL nHandle

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML com o registro do cabeçalho não informado.'
   ENDIF
   IF ::rps_InscricaoMunicipalPrestador = NIL .OR. Empty( ::rps_InscricaoMunicipalPrestador )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Inscrição Municipal do Prestador. Verificar regra de preenchimento do campo no Anexo 03.'
   ENDIF
   IF ::rps_RazaoSocialPrestador = NIL .OR. Empty( ::rps_RazaoSocialPrestador )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Razão Social do Prestador.'
   ENDIF
   IF ::rps_TipoRPS = NIL .OR. Empty( ::rps_TipoRPS )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Tipo de RPS Padrão "RPS".'
   ENDIF
   IF ::rps_SerieRPS = NIL .OR. Empty( ::rps_SerieRPS )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Série do RPS - Padrão "NF".'
   ENDIF
   IF ::rps_NumeroRPS = NIL .OR. ::rps_NumeroRPS <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o Número da RPS.'
   ENDIF
   IF ::rps_NumeroRPS = NIL .OR. ::rps_NumeroRPS <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o Número da RPS.'
   ENDIF
   IF ::rps_DataEmissaoRPS = NIL .OR. Day( ::rps_DataEmissaoRPS ) <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o Data de Emissão da RPS.'
   ENDIF
   IF ::rps_SituacaoRPS = NIL .OR. Empty( ::rps_SituacaoRPS )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Situação da RPS - "N"-Normal, "C"-Cancelada.'
   ENDIF
   hb_Default( @::rps_SerieRPSSubstituido, "" )
   IF ::rps_SituacaoRPS = NIL .OR. Empty( ::rps_SituacaoRPS )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Situação da RPS - "N"-Normal, "C"-Cancelada.'
   ENDIF
   hb_Default( @::rps_NumeroRPSSubstituido, 0 )
   hb_Default( @::rps_NumeroNFSeSubstituida, 0 )
   IF ::rps_DataEmissaoNFSeSubstituida = NIL .OR. Day( ::rps_DataEmissaoNFSeSubstituida ) <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar a Data de emissão da NFSe Formato= AAAA-MM-DD. Se não for substituto preencher com "01/01/1900".'
   ENDIF
   IF ::rps_SeriePrestacao = NIL .OR. Empty( ::rps_SeriePrestacao )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Número do equipamento emissor do RPS ou série de prestação. Caso não utilize a série, preencha o campo com o valor ‘99’ que indica modelo único. Caso queira utilizar o campo série para indicar o número do equipamento emissor do RPS deve-se solicitar liberação da prefeitura.'
   ENDIF
   IF ::rps_InscricaoMunicipalTomador = NIL .OR. Empty( ::rps_InscricaoMunicipalTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Inscrição Municipal do Tomador. Caso o tomador não for do municipio não preencher, caso o tomador for do município preencher com a Inscrição Municipal formatada Seguindo Anexo 03.'
   ENDIF
   IF ::rps_CPFCNPJTomador = NIL .OR. Empty( ::rps_CPFCNPJTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o CPF ou CNPJ do Tomador. Ex: "00000000000191"'
   ENDIF
   IF ::rps_RazaoSocialTomador = NIL .OR. Empty( ::rps_RazaoSocialTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Razão Social do Tomador'
   ENDIF
   hb_Default( @::rps_DocTomadorEstrangeiro, "" )
   IF ::rps_TipoLogradouroTomador = NIL .OR. Empty( ::rps_TipoLogradouroTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Tipo de Logradouro do Tomador. Campo de preenchimento livre. Verificar exemplos no anexo 04.'
   ENDIF
   IF ::rps_LogradouroTomador = NIL .OR. Empty( ::rps_LogradouroTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Logradouro do Tomador.'
   ENDIF
   IF ::rps_NumeroEnderecoTomador = NIL .OR. Empty( ::rps_NumeroEnderecoTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Numero de Endereço do Tomador.'
   ENDIF
   hb_Default( @::rps_ComplementoEnderecoTomador, "" )
   IF ::rps_TipoBairroTomador = NIL .OR. Empty( ::rps_TipoBairroTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Tipo de Bairro do Tomador . Campo de preenchimento livre. Verificar exemplos no Anexo 05.'
   ENDIF
   IF ::rps_BairroTomador = NIL .OR. Empty( ::rps_BairroTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Bairro do Tomador.'
   ENDIF
   IF ::rps_CidadeTomador = NIL .OR. ::rps_CidadeTomador <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o Código da Cidade do Tomador padrão SIAFI. (Confira o nome da cidade no cadastro do cliente)'
   ENDIF
   IF ::rps_CidadeTomadorDescricao = NIL .OR. Empty( ::rps_CidadeTomadorDescricao )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Nome da Cidade do Tomador.'
   ENDIF
   IF ::rps_CEPTomador = NIL .OR. Empty( ::rps_CEPTomador )
      aRETORNO[ 'MSG' ] := 'Favor Informar o CEP do Tomador Ex: "37900000".'
   ENDIF
   IF ::rps_EmailTomador = NIL .OR. Empty( ::rps_EmailTomador )
      ::rps_EmailTomador := '-'
   ENDIF
   IF ::rps_CodigoAtividade = NIL .OR. Empty( ::rps_CodigoAtividade )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Código da Atividade da RPS. (Confira o codigo CNAE no cadastro do cliente)'
   ENDIF
   hb_Default( @::rps_AliquotaAtividade, 0 )
   IF ::rps_TipoRecolhimento = NIL .OR. Empty( ::rps_TipoRecolhimento )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Tipo de Recolhimento - "A" – A Receber, "R" - Retido na Fonte.'
   ENDIF
   IF ::rps_MunicipioPrestacao = NIL .OR. ::rps_MunicipioPrestacao <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o Código do Município de Prestação – Padrão SIAFI.'
   ENDIF
   IF ::rps_MunicipioPrestacao = NIL .OR. ::rps_MunicipioPrestacao <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o Código do Município de Prestação – Padrão SIAFI.'
   ENDIF
   IF ::rps_MunicipioPrestacaoDescricao = NIL .OR. Empty( ::rps_MunicipioPrestacaoDescricao )
      aRETORNO[ 'MSG' ] := 'Favor Informar o Município de Prestação do Serviço.'
   ENDIF
   IF ::rps_Operacao = NIL .OR. Empty( ::rps_Operacao )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Operação - "A"-Sem Dedução, "B"-Com Dedução/Materiais, "C" - Imune/Isenta de ISSQN, "D" - Devolução/Simples Remessa, "J" - Intemediação.'
   ENDIF
   IF ::rps_Tributacao = NIL .OR. Empty( ::rps_Tributacao )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Tributação: C - Isenta de ISS, E - Não Incidência no Município, F - Imune, K - Exigibilidd Susp.Dec.J/Proc.A, N - Não Tributável, T – Tributável, G - Tributável Fixo, H - Tributável S.N., M - Micro Empreendedor Individual (MEI).'
   ENDIF
   hb_Default( @::rps_ValorPIS, 0.00 )
   hb_Default( @::rps_ValorCOFINS, 0.00 )
   hb_Default( @::rps_ValorINSS, 0.00 )
   hb_Default( @::rps_ValorIR, 0.00 )
   hb_Default( @::rps_ValorCSLL, 0.00 )
   hb_Default( @::rps_AliquotaPIS, 0.00 )
   hb_Default( @::rps_AliquotaCOFINS, 0.00 )
   hb_Default( @::rps_AliquotaINSS, 0.00 )
   hb_Default( @::rps_AliquotaIR, 0.00 )
   hb_Default( @::rps_AliquotaCSLL, 0.00 )
   hb_Default( @::rps_DescricaoRPS, "" )
   hb_Default( @::rps_DDDPrestador, "" )
   hb_Default( @::rps_TelefonePrestador, "" )
   hb_Default( @::rps_DDDTomador, "" )
   hb_Default( @::rps_TelefoneTomador, "" )
   hb_Default( @::rps_MotCancelamento, "" )
   hb_Default( @::rps_CPFCNPJIntermediario, "" )

   IF !Empty( aRETORNO[ 'MSG' ] )
      RETURN aRETORNO
   ENDIF

   cXML := MemoRead( ::Xml )
   FErase( ::Xml )

   cAssinatura := ::Gera_Chave_SHA1()
   cXML +=   '<RPS xmlns="">' // '<RPS Id="rps:2">'
   cXML +=    XmlTag( "Assinatura", cAssinatura )
   cXML +=    '<ChaveRPS>'
   cXML +=      XmlTag( "InscricaoPrestador", AllTrim( ::rps_InscricaoMunicipalPrestador ) )
   cXML +=      XmlTag( "SerieRPS", AllTrim( ::rps_SerieRPS ) )
   cXML +=      XmlTag( "NumeroRPS", AllTrim( Str( ::rps_NumeroRPS ) ) )
   cXML +=    '</ChaveRPS>'
   cXML +=    XmlTag( "TipoRPS", AllTrim( ::rps_TipoRPS ) )
   cXML +=    XmlTag( "DataEmissao", DateXml( ::rps_DataEmissaoRPS ) )
   cXML +=    XmlTag( "StatusRPS", AllTrim( ::rps_SituacaoRPS ) )
   cXML +=    XmlTag( "TributacaoRPS", AllTrim( ::rps_Tributacao ) )
   cXML +=    XmlTag( "ValorServicos", AllTrim( Str( ::cab_ValorTotalServicos ) ) )
   cXML +=    XmlTag( "ValorDeducoes", AllTrim( Str( ::cab_ValorTotalDeducoes ) ) )
   cXML +=    XmlTag( "CodigoServico", ::rps_CodigoAtividade )
   cXML +=    XmlTag( "AliquotaServicos", AllTrim( Str( ::rps_AliquotaAtividade ) ) )
   cXML +=    XmlTag( "ISSRetido", "false" )

   // V10.0.K1608
   // cXML+=    '<CPFCNPJTomador><CPF>'+ALLTRIM(::rps_CPFCNPJTomador)+'</CPF></CPFCNPJTomador>'
   IF Len( AllTrim( ::rps_CPFCNPJTomador ) ) == 14
      cXML +=    '<CPFCNPJTomador>' + XmlTag( "CNPJ", AllTrim( ::rps_CPFCNPJTomador ) ) + '</CPFCNPJTomador>'
   ELSE
      cXML +=    '<CPFCNPJTomador>' + XmlTag( "CPF", AllTrim( ::rps_CPFCNPJTomador ) ) + '</CPFCNPJTomador>'
   ENDIF
   // V10.0.K1608

   cXML +=    XmlTag( "RazaoSocialTomador", AllTrim( ::rps_RazaoSocialTomador ) )
   cXML +=    '<EnderecoTomador>'
   cXML +=      XmlTag( "TipoLogradouro", AllTrim( ::rps_TipoLogradouroTomador ) )
   cXML +=      XmlTag( "Logradouro", AllTrim( ::oFuncoes:parseEncode( ::rps_LogradouroTomador ) ) )
   cXML +=      XmlTag( "NumeroEndereco", AllTrim( ::rps_NumeroEnderecoTomador ) )
   cXML +=      XmlTag( "ComplementoEndereco", AllTrim( ::oFuncoes:parseEncode( ::rps_ComplementoEnderecoTomador ) ) )
   cXML +=      XmlTag( "Bairro", AllTrim( ::oFuncoes:parseEncode( ::rps_BairroTomador ) ) )
   cXML +=      XmlTag( "Cidade", AllTrim( Str( ::rps_CidadeTomador ) ) )
   cXML +=      XmlTag( "UF", "SP" )
   cXML +=      XmlTag( "CEP", AllTrim( ::rps_CEPTomador ) )
   cXML +=    '</EnderecoTomador>'
   cXML +=    XmlTag( "EmailTomador", AllTrim( ::oFuncoes:parseEncode( ::rps_EmailTomador ) ) )
   cXML +=    XmlTag( "Discriminacao", AllTrim( ::Itens_DiscriminacaoServico ) )

   // V10.0.K1292
   cXML +=    XmlTag( "ValorCargaTributaria", ::cValorCargaTributaria )
   cXML +=    XmlTag( "PercentualCargaTributaria", ::cPercentualCargaTributaria )
   cXML +=    XmlTag( "FonteCargaTributaria", "P.I.085/14" )
   // V10.0.K1292

   cXML +=   '</RPS>'

   cXML := ::oFuncoes:RemoveAcentuacao( cXML )

   nHandle := FCreate( ::XML )
   FWrite( nHandle, cXML )
   FClose( nHandle )

   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := ::XML
   aRETORNO[ 'MSG' ] := 'XML criado em ' + ::XML

   RETURN aRETORNO

METHOD Registro_Itens_RPS( lABRE, lFECHA ) CLASS NFSE

   LOCAL aRETORNO := Hash()
   LOCAL cXML
   LOCAL nHandle

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML com o registro do cabeçalho e RPS não informado.'
   ENDIF
   IF ::Itens_DiscriminacaoServico = NIL .OR. Empty( ::Itens_DiscriminacaoServico )
      aRETORNO[ 'MSG' ] := 'Favor informar a Discriminação do Serviço.'
   ENDIF
   IF ::Itens_Quantidade = NIL .OR. ::Itens_Quantidade <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar a Quantidade do serviço tomado.'
   ENDIF
   IF ::Itens_ValorUnitario = NIL .OR. ::Itens_ValorUnitario <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar o Valor Unitário do serviço tomado.'
   ENDIF
   IF ::Itens_ValorTotal = NIL .OR. ::Itens_ValorTotal <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar o Valor total do serviço tomado.'
   ENDIF
   IF ::Itens_Tributavel = NIL
      ::Itens_Tributavel := ''
   ENDIF

   IF !Empty( aRETORNO[ 'MSG' ] )
      RETURN aRETORNO
   ENDIF

   cXML := MemoRead( ::Xml )
   FErase( ::Xml )

   IF lABRE
      cXML += '<Itens>'
   ENDIF

   IF lFECHA
      cXML += '</Itens>'
   ENDIF

   nHandle := FCreate( ::Xml )
   FWrite( nHandle, cXML )
   FClose( nHandle )

   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := ::Xml
   aRETORNO[ 'MSG' ] := 'XML criado em ' + ::Xml

   RETURN aRETORNO

METHOD Registro_Deducao_RPS( /* lABRE,lFECHA */ )

   LOCAL aRETORNO := Hash()
   LOCAL cXML
   LOCAL nHandle

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML com o registro do cabeçalho e RPS não informado.'
   ENDIF

   IF !Empty( aRETORNO[ 'MSG' ] )
      RETURN aRETORNO
   ENDIF

   cXML := MemoRead( ::Xml )
   FErase( ::Xml )

   nHandle := FCreate( ::Xml )
   FWrite( nHandle, cXML )
   FClose( nHandle )

   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := ::Xml
   aRETORNO[ 'MSG' ] := 'XML criado em ' + ::Xml

   RETURN aRETORNO

METHOD Finaliza_RPS() CLASS NFSE

   LOCAL aRETORNO := Hash()
   LOCAL cXML
   LOCAL nHandle
   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML com o registro do cabeçalho e RPS não informado.'
   ENDIF

   cXML := MemoRead( ::Xml )

   FErase( ::Xml )

   cXML += XmlTag( "Signature", "" )

   cXML += '</PedidoEnvioLoteRPS>'

   nHandle := FCreate( ::Xml )
   FWrite( nHandle, cXML )
   FClose( nHandle )

   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := ::Xml
   aRETORNO[ 'MSG' ] := 'XML criado em ' + ::Xml

   RETURN aRETORNO

METHOD Assina_XML() CLASS NFSE

   LOCAL oDOMDoc, oXmldsig, oCert, oStoreMem, dsigKey, signedKey
   LOCAL aRETORNO := Hash()
   LOCAL cXML, cXMLSig
   LOCAL PosIni, PosFim, nP, nResult
   LOCAL nHandle

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML com o registro do cabeçalho e RPS não informado.'
   ENDIF
   cXML := MemoRead( ::Xml )
   FErase( ::Xml )

   cXML := StrTran( cXML, '<Signature></Signature>', '<Signature xmlns="http://www.w3.org/2000/09/xmldsig#">' + ;
      '<SignedInfo>' + ;
      '<CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" />' + ;
      '<SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1" />' + ;
      '<Reference URI="">' + ;
      '<Transforms>' + ;
      '<Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" />' + ;
      '<Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" />' + ;
      '</Transforms>' + ;
      '<DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1" />' + ;
      '<DigestValue>' + ;
      '</DigestValue>' + ;
      '</Reference>' + ;
      '</SignedInfo>' + ;
      '<SignatureValue>' + ;
      '</SignatureValue>' + ;
      '<KeyInfo>' + ;
      '<X509Data>' + ;
      '<X509Certificate>' + ;
      '</X509Certificate>' + ;
      '</X509Data>' + ;
      '</KeyInfo>' + ;
      '</Signature>' )

// Inicializa o objeto do DOMDocument
   BEGIN SEQUENCE WITH __BreakBlock()
      oDOMDoc := win_oleCreateObject( _MSXML2_DOMDOCUMENT )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Nao foi possível carregar ' + _MSXML2_DOMDOCUMENT
      RETURN aRETORNO
   ENDSEQUENCE
   oDOMDoc:async = .F.
   oDOMDoc:resolveExternals := .F.
   oDOMDoc:validateOnParse = .T.
   oDOMDoc:preserveWhiteSpace = .T.

// inicializa o objeto do MXDigitalSignature
   BEGIN SEQUENCE WITH __BreakBlock()
      oXmldsig := win_oleCreateObject( _MSXML2_MXDIGITALSIGNATURE )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Nao foi possível carregar ' + _MSXML2_MXDIGITALSIGNATURE
      RETURN aRETORNO
   ENDSEQUENCE

   nHandle := FCreate( ::ohbNFe:pastaEnvRes + "\edunfs.xml" )
   FWrite( nHandle, cXML )
   FClose( nHandle )

// carrega o arquivo XML para o DOM
   oDOMDoc:LoadXML( cXML )
   IF oDOMDoc:parseError:errorCode <> 0
      aRETORNO[ 'MSG' ] := ' Assinar: Não foi possível carregar o documento pois ele não corresponde ao seu Schema' + hb_Eol() + ;
         ' Linha: '       + Str( oDOMDoc:parseError:line ) + hb_eol() + ;
         ' Caractere na linha: ' + Str( oDOMDoc:parseError:linepos ) + hb_eol() + ;
         ' Causa do erro: '   + oDOMDoc:parseError:reason + hb_eol() + ;
         ' code: '       + Str( oDOMDoc:parseError:errorCode )
      RETURN aRETORNO
   ENDIF

// Localiza as assinaturas no XML
   oDOMDoc:SETPROPERTY( 'SelectionNamespaces', "xmlns:ds='http://www.w3.org/2000/09/xmldsig#'" )
   oXmldsig:signature := oDOMDoc:selectSingleNode( './/ds:Signature' )
   IF ( oXmldsig:signature = nil )
      aRETORNO[ 'MSG' ] := 'É preciso carregar o template antes de assinar.'
      RETURN aRETORNO
   ENDIF

// carrega o objeto do certificado digital
   oCert := ::ohbNFe:pegaObjetoCertificado( ::ohbNFe:cSerialCert )

   IF oCert == Nil
      aRETORNO[ 'MSG' ] := 'Certificado não encontrado, Favor revisar a instalação do Certificado'
      RETURN aRETORNO
   ENDIF

// cria o objeto de Store da capicom
   oStoreMem := win_oleCreateObject( 'CAPICOM.Store' )

// Aloca o certificado na memoria
   BEGIN SEQUENCE WITH __BreakBlock()
      oStoreMem:open( _CAPICOM_MEMORY_STORE, 'Memoria', _CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED )
   RECOVER // CATCH oError
      aRETORNO[ 'MSG' ] := 'Falha ao alocar o certificado na memoria ' + hb_eol() + ;
         'Error: '  + Transform( oError:GenCode, nil ) + ';' + hb_eol() + ;
         'SubC: '   + Transform( oError:SubCode, nil ) + ';' + hb_eol() + ;
         'OSCode: '  + Transform( oError:OsCode, nil ) + ';' + hb_eol() + ;
         'SubSystem: ' + Transform( oError:SubSystem, nil ) + ';' + hb_eol() + ;
         'Mensangem: ' + oError:Description
      RETURN aRETORNO
   ENDSEQUENCE

// Aloca o certificado na Capicom
   BEGIN SEQUENCE WITH __BreakBlock()
      oStoreMem:Add( oCert )
   RECOVER // CATCH oError
      aRETORNO[ 'MSG' ] := 'Falha ao aloca o certificado na memoria da Capicom ' + hb_eol() + ;
         'Error: '  + Transform( oError:GenCode, nil ) + ';' + hb_eol() + ;
         'SubC: '   + Transform( oError:SubCode, nil ) + ';' + hb_eol() + ;
         'OSCode: '  + Transform( oError:OsCode, nil ) + ';' + hb_eol() + ;
         'SubSystem: ' + Transform( oError:SubSystem, nil ) + ';' + hb_eol() + ;
         'Mensangem: ' + oError:Description
      RETURN aRETORNO
   ENDSEQUENCE
   oXmldsig:store := oStoreMem

// Cria chave CSP
   BEGIN SEQUENCE WITH __BreakBlock()
      dsigKey := oXmldsig:createKeyFromCSP( oCert:PrivateKey:ProviderType, oCert:PrivateKey:ProviderName, oCert:PrivateKey:ContainerName, 0 )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Erro ao criar a chave do CSP, talvez o certificado não esteja instalado corretamente.'
      RETURN aRETORNO
   ENDSEQUENCE
   IF ( dsigKey = nil )
      aRETORNO[ 'MSG' ] := 'Erro ao criar a chave do CSP.'
      RETURN aRETORNO
   ENDIF

// Assina a chave do CSP
   BEGIN SEQUENCE WITH __BreakBlock()
      signedKey := oXmldsig:Sign( dsigKey, 2 )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Erro ao assinar a chave do CSP, talvez o certificado não esteja instalado corretamente.'
      RETURN aRETORNO
   ENDSEQUENCE
   IF signedKey = NIL
      aRETORNO[ 'MSG' ] := 'Assinatura Falhou.'
      RETURN( aRetorno )
   ENDIF

// Trata o formato da estrutura do XML
   cXMLSig := StrTran( StrTran( oDOMDoc:xml, Chr( 10 ) ), Chr( 13 ) )
   PosIni := At( '<SignatureValue>', cXMLSig ) + Len( '<SignatureValue>' )
   cXMLSig := SUBS( cXMLSig, 1, PosIni - 1 ) + StrTran( SUBS( cXMLSig, PosIni, Len( cXMLSig ) ), ' ', '' )
   PosIni := At( '<X509Certificate>', cXMLSig ) - 1
   nP   := At( '<X509Certificate>', cXMLSig )
   nResult := 0
   DO WHILE nP <> 0
      nResult := nP
      nP = WAT( '<X509Certificate>', cXMLSig, nP + 1 )
   ENDDO
   PosFim := nResult
   cXMLSig := SUBS( cXMLSig, 1, PosIni ) + SUBS( cXMLSig, PosFim, Len( cXMLSig ) )
   cXMLsig := StrTran( cXMLsig, 'Id="rps:1"', '' )

// grava o arquivo no disco
   nHandle := FCreate( ::Xml )
   FWrite( nHandle, cXMLSig )
   FClose( nHandle )

   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := ::Xml
   aRETORNO[ 'MSG' ] := 'XML assinado com sucesso em ' + ::Xml

   RETURN aRETORNO

METHOD LinkWebService() CLASS NFSE

   LOCAL cWeb := ''

   IF ::cab_CodCidade = 3550308 // SÆo Paulo-SP
      cWeb := 'https://nfe.prefeitura.sp.gov.br/ws/lotenfe.asmx'
   ENDIF

   RETURN cWeb

METHOD ctPegaCNCertificado() CLASS NFSE

   LOCAL oStore, oCertificados
   LOCAL cSubjectName := '', cCN := ''
   LOCAL mI

   BEGIN SEQUENCE WITH __BreakBlock()
      oStore := win_oleCreateObject( "CAPICOM.Store" )
   END SEQUENCE

   IF oStore = Nil
      RETURN ''
   ENDIF

   oStore:open( _CAPICOM_CURRENT_USER_STORE, 'My', _CAPICOM_STORE_OPEN_MAXIMUM_ALLOWED )
   oCertificados := oStore:Certificates()
   FOR mI = 1 TO oCertificados:Count()
      IF oCertificados:Item( mI ):SerialNumber = ::ohbNFe:cSerialCert
         cSubjectName := oCertificados:Item( mI ):SubjectName
      ENDIF
   NEXT
   cCN := ''
   FOR mI := At( "CN=", cSubjectName ) + 3 TO Len( cSubjectName )
      IF SUBS( cSubjectName, mI, 1 ) == ","
         EXIT
      ENDIF
      cCN += SUBS( cSubjectName, mI, 1 )
   NEXT
   oCertificados := Nil
   oStore := Nil

   RETURN cCN

METHOD ComunicaWebService( cMethod ) CLASS NFSE

   LOCAL oServerWS
   LOCAL oDOMDoc
   LOCAL aRETORNO := Hash()
   LOCAL cCERT   := ''
   LOCAL cUrlWS
   LOCAL cXML
   LOCAL cNameSpace

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML assinado de RPS não informado.'
   ENDIF

   cXML := MemoRead( ::Xml )
// FERASE(::Xml)

   IF Empty( cXML )

      aRETORNO[ 'MSG' ] := 'Favor informar o arquivo de XML.'
      RETURN aRETORNO

   ENDIF

   IF cMethod == 'cancelar'

      cNameSpace := "CancelamentoNFeRequest"

   ELSE

      IF .F. // WSet( LPK_B_PC_TEC ) // NÆo est funcionando
         cNameSpace := "TesteEnvioLoteRPSRequest"
      ELSE
         cNameSpace := "EnvioLoteRPSRequest"
      ENDIF

   ENDIF

   cXML := '<?xml version="1.0" encoding="utf-8"?>' + ;
      '<soap12:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' + ;
      'xmlns:xsd="http://www.w3.org/2001/XMLSchema" ' + ;
      'xmlns:soap12="http://schemas.xmlsoap.org/soap/envelope/">' + ;
      '<soap12:Body>' + ;
      '<' + cNameSpace + ' xmlns="http://www.prefeitura.sp.gov.br/nfe">' + ;
      '<VersaoSchema>1</VersaoSchema>' + ;
      '<MensagemXML> ' + ;
      '<![CDATA[ ' + cXML + ' ]]>' + ;
      '</MensagemXML>' + ;
      '</' + cNameSpace + '>' + ;
      '</soap12:Body>' + ;
      '</soap12:Envelope>'

   nHandle := FCreate( ::ohbNFe:pastaEnvRes + "\edunfs.xml" )
   FWrite( nHandle, cXML )
   FClose( nHandle )

   BEGIN SEQUENCE WITH __BreakBlock()

      // cCERT := ::ctPegaCNCertificado()
      cCERT := ::ohbNFe:pegaCNCertificado( SetaCros( GC_NFE_NS_CERTIF ) )

   ENDSEQUENCE

   IF Empty( cCERT )

      aRETORNO[ 'MSG' ] := 'Não foi possível carregar as informações do certificado.'
      RETURN aRETORNO

   ENDIF

   cUrlWS := ::LinkWebService()

   IF Empty( cUrlWS )

      aRETORNO[ 'MSG' ] := 'Webservice não localizado'
      RETURN aRETORNO

   ENDIF

   BEGIN SEQUENCE WITH __BreakBlock()

      oServerWS := win_oleCreateObject( _MSXML2_SERVERXMLHTTP )
      oServerWS:setOption( 3, 'CURRENT_USER\MY\' + cCERT )
      oServerWS:open( 'POST', cUrlWS, .F. )
      IF .F. // WSet( LPK_B_PC_TEC ) // NÆo est funcionando
         oServerWS:setRequestHeader( 'SOAPAction', 'http://www.prefeitura.sp.gov.br/nfe/ws/testeenvio' )
      ELSE
         IF cMethod == 'cancelar'
            oServerWS:setRequestHeader( 'SOAPAction', 'http://www.prefeitura.sp.gov.br/nfe/ws/cancelamentoNFe' )
         ELSE
            oServerWS:setRequestHeader( 'SOAPAction', 'http://www.prefeitura.sp.gov.br/nfe/ws/envioLoteRPS' )
         ENDIF
      ENDIF

      oServerWS:setRequestHeader( 'Content-Type', 'text/xml; charset=utf-8' )

   RECOVER

      aRETORNO[ 'MSG' ] := 'Não foi possível inicializar a conexão do webservice'
      RETURN aRETORNO

   ENDSEQUENCE

   IF oServerWS = NIL
      aRETORNO[ 'MSG' ] := 'Não foi possível inicializar o objeto de conexão do webservice'
      RETURN aRETORNO
   ENDIF

   BEGIN SEQUENCE WITH __BreakBlock()

      oDOMDoc := win_oleCreateObject( _MSXML2_DOMDOCUMENT )
      oDOMDoc:async = .F.
      oDOMDoc:validateOnParse = .T.
      oDOMDoc:resolveExternals := .F.
      oDOMDoc:preserveWhiteSpace = .T.
      oDOMDoc:LoadXML( cXML )

   RECOVER

      aRETORNO[ 'MSG' ] := 'Não foi possível carregar o documento XML'
      RETURN aRETORNO

   ENDSEQUENCE

   IF oDOMDoc:parseError:errorCode <> 0

      aRETORNO[ 'MSG' ] := 'Não foi possível carregar o documento pois ele não corresponde ao seu Schema' + hb_eol() + ;
         ' Linha: ' + Str( oDOMDoc:parseError:line )                   + hb_eol() + ;
         ' Caractere na linha: ' + Str( oDOMDoc:parseError:linepos )           + hb_eol() + ;
         ' Causa do erro: ' + oDOMDoc:parseError:reason                 + hb_eol() + ;
         ' Code: ' + Str( oDOMDoc:parseError:errorCode )
      RETURN aRETORNO

   ENDIF

   BEGIN SEQUENCE WITH __BreakBlock()

      oServerWS:send( oDOMDoc:xml )

   RECOVER // CATCH e

      aRETORNO[ 'MSG' ] := 'Falha: Não foi possível conectar-se ao servidor do SEFAZ, Servidor inativo ou inoperante.' + hb_eol() + ;
         'Error: ' + Transform( e:GenCode, nil )                          + ';' + hb_eol() + ;
         'SubC: ' + Transform( e:SubCode, nil )                           + ';' + hb_eol() + ;
         'OSCode: ' + Transform( e:OsCode, nil )                          + ';' + hb_eol() + ;
         'SubSystem: ' + Transform( e:SubSystem, nil )                       + ';' + hb_eol() + ;
         'Mensangem: ' + e:Description
      Wint( aRETORNO[ 'MSG' ] )
      RETURN aRETORNO

   ENDSEQUENCE

   oServerWs:WaitForResponse( 500 )

   aRETORNO[ 'MSG' ] := 'Comunicação com o webservice finalizada com sucesso.'
   aRETORNO[ 'STATUS' ] := .T.
   aRETORNO[ 'XML' ] := oServerWS:responseText

   nHandle := FCreate( ::ohbNFe:pastaEnvRes + "\eduret.xml" )
   FWrite( nHandle, AlteraCaracteres( oServerWS:responseText, .T. ) )
   FClose( nHandle )

   oDOMDoc := Nil
   oServerWS := Nil

   RETURN aRETORNO

METHOD CancelaNFSe() CLASS NFSE

   LOCAL cXML := ''
   LOCAL aRETORNO := Hash()
   LOCAL nHandle
   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::cab_CodCidade = NIL .OR. ::cab_CodCidade <= 0
      aRETORNO[ 'MSG' ] := 'Favor informar o código do município'
   ENDIF
   IF ::cab_CPFCNPJRemetente = NIL .OR. Empty( ::cab_CPFCNPJRemetente )
      aRETORNO[ 'MSG' ] := 'Favor informar o CPF / CNPJ do Remetente'
   ENDIF
   IF ::rps_InscricaoMunicipalPrestador = NIL .OR. Empty( ::rps_InscricaoMunicipalPrestador )
      aRETORNO[ 'MSG' ] := 'Favor Informar a Inscrição Municipal do Prestador. Verificar regra de preenchimento do campo no Anexo 03.'
   ENDIF
   IF ::numero_nota = NIL .OR. ::numero_nota <= 0
      aRETORNO[ 'MSG' ] := 'Favor Informar o número da nota a ser cancelada.'
   ENDIF
// IF ::codigo_verificacao=NIL .OR. EMPTY(::codigo_verificacao)
// aRETORNO['MSG']:='Favor Informar o código verificador.'
// ENDIF

   IF !Empty( aRETORNO[ 'MSG' ] )
      aRETORNO[ "STATUS" ] := .F.
      RETURN aRETORNO
   ENDIF

   cXML += '<PedidoCancelamentoNFe xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://www.prefeitura.sp.gov.br/nfe">'

   cXML += '<Cabecalho Versao="1" xmlns="">'
   cXML +=  '<CPFCNPJRemetente>'
   cXML +=   '<CNPJ>' + AllTrim( ::cab_CPFCNPJRemetente ) + '</CNPJ>'
   cXML +=  '</CPFCNPJRemetente>'
   cXML +=  '<transacao>true</transacao>'
   cXML += '</Cabecalho>'
   cXML += '<Detalhe xmlns="">'
   cXML +=  '<ChaveNFe>'
   cXML +=   '<InscricaoPrestador>' + AllTrim( ::rps_InscricaoMunicipalPrestador ) + '</InscricaoPrestador>'
   cXML +=   '<NumeroNFe>' + AllTrim( Str( ::numero_nota ) ) + '</NumeroNFe>'
   cXML +=  '</ChaveNFe>'
   cXML +=  '<AssinaturaCancelamento>' + ::Gera_Chave_SHA1_Cancelamento() + '</AssinaturaCancelamento>'
   cXML += '</Detalhe>'
   cXML += '<Signature></Signature>'
   cXML += '</PedidoCancelamentoNFe>'

   ::Xml := ::ohbNFe:pastaEnvRes + '\NFSe_canc' + AllTrim( ::cab_CPFCNPJRemetente ) + DToS( Date() ) + StrTran( Left( Time(), 8 ), ':' ) + '.xml'

   nHandle := FCreate( ::Xml )
   FWrite( nHandle, cXML )
   FClose( nHandle )

   aRETORNO := ::Assina_XML()
   IF !aRETORNO[ 'STATUS' ]
      RETURN aRETORNO
   ENDIF

// aRETORNO:=::ValidaXML()
// IF !aRETORNO['STATUS']
// RETURN aRETORNO
// ENDIF

   aRETORNO := ::ComunicaWebService( 'cancelar' )
   IF !aRETORNO[ 'STATUS' ]
      RETURN aRETORNO
   ENDIF

   aRETORNO := ::LeRetorno( aRETORNO[ 'XML' ] )

   IF !aRETORNO[ 'STATUS' ]
      RETURN aRETORNO
   ENDIF

   RETURN aRETORNO

METHOD LeRetorno( cRET ) CLASS NFSE

   LOCAL aRETORNO := Hash()
   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   cRET := StrTran( cRET, '&lt;', '<' )
   cRET := StrTran( cRET, '&gt;', '>' )
   cRET := StrTran( cRET, '&quot;', '"' )

   IF '<Erros>' $ cRET
      cRET := ::oFuncoes:pegaTag( cRET, 'Erro' )
      aRETORNO[ 'CODIGO' ] := ::oFuncoes:pegaTag( cRET, 'Codigo' )
      aRETORNO[ 'DESCRICAO' ] := ::oFuncoes:pegaTag( cRET, 'Descricao' )
      aRETORNO[ 'MSG' ] := aRETORNO[ 'CODIGO' ] + '-' + aRETORNO[ 'DESCRICAO' ]
   ELSEIF '<Alertas>' $ cRET
      cRET := ::oFuncoes:pegaTag( cRET, 'Alerta' )
      aRETORNO[ 'CODIGO' ] := ::oFuncoes:pegaTag( cRET, 'Codigo' )
      aRETORNO[ 'DESCRICAO' ] := ::oFuncoes:pegaTag( cRET, 'Descricao' )
      aRETORNO[ 'MSG' ] := aRETORNO[ 'CODIGO' ] + '-' + aRETORNO[ 'DESCRICAO' ]
   ELSEIF '>false<' $ cRET
      aRETORNO[ 'STATUS' ]  := .F.
      aRETORNO[ 'CODIGO' ]  := ::oFuncoes:pegaTag( cRET, 'Codigo' )
      aRETORNO[ 'DESCRICAO' ] := ::oFuncoes:pegaTag( cRET, 'Descricao' )
      aRETORNO[ 'MSG' ]   := aRETORNO[ 'DESCRICAO' ]
   ELSE
      aRETORNO[ 'STATUS' ] := .T.
   ENDIF

   RETURN aRETORNO

METHOD ValidaXML() CLASS NFSE

   LOCAL oDOMDoc, oSchema, ParseError
   LOCAL aRETORNO := Hash()
   LOCAL cSchemaFilename := ''

   aRETORNO[ 'STATUS' ] := .F.
   aRETORNO[ 'MSG' ] := ''

   IF ::Xml = NIL .OR. Empty( ::Xml )
      aRETORNO[ 'MSG' ] := 'Arquivo XML assinado de RPS não informado.'
   ENDIF

   cXML := MemoRead( ::Xml )
   wint( "VALIDA" )
   IF 'ReqEnvioLoteRPS' $ cXML // Envio de lote
      cXML := StrTran( cXML, ' xmlns:tipos="http://localhost:8080/WsNFe2/tp" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://localhost:8080/WsNFe2/lote http://localhost:8080/WsNFe2/xsd/ReqEnvioLoteRPS.xsd"' )
      cSchemaFilename := ::ohbNFe:cPastaSchemas + '\ReqEnvioLoteRPS.xsd'
   ELSEIF 'ReqCancelamentoNFSe' $ cXML // Cancelamento de NFSe
      cXML := StrTran( cXML, ' xmlns:tipos="http://localhost:8080/WsNFe2/tp" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://localhost:8080/WsNFe2/lote http://localhost:8080/WsNFe2/xsd/ReqCancelamentoNFSe.xsd"' )
      cSchemaFilename := ::ohbNFe:cPastaSchemas + '\ReqCancelamentoNFSe.xsd'
   ENDIF

   BEGIN SEQUENCE WITH __BreakBlock()
      oDOMDoc := win_OleCreateObject( _MSXML2_DOMDOCUMENT )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Não foi possível carregar o MSXML para validação do XML.'
      RETURN aRETORNO
   ENDSEQUENCE

   BEGIN SEQUENCE WITH __BreakBlock()
      oDOMDoc:async = .F.
      oDOMDoc:resolveExternals := .F.
      oDOMDoc:validateOnParse = .T.
      oDOMDoc:LoadXML( cXML )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Não foi possível carregar o arquivo XML para a validação.'
      RETURN aRETORNO
   ENDSEQUENCE
   IF oDOMDoc:parseError:errorCode <> 0 // XML não carregado
      aRETORNO[ 'MSG' ] := 'Não foi possível carregar o documento pois ele não corresponde ao seu Schema' + hb_eol() + ;
         'Linha: ' + Str( oDOMDoc:parseError:line )                    + hb_eol() + ;
         'Caractere na linha: ' + Str( oDOMDoc:parseError:linepos )            + hb_eol() + ;
         'Causa do erro: ' + oDOMDoc:parseError:reason                 + hb_eol() + ;
         'Code: ' + Str( oDOMDoc:parseError:errorCode )
      RETURN aRETORNO
   ENDIF

   BEGIN SEQUENCE WITH __BreakBlock()
      oSchema := win_OleCreateObject( _MSXML2_XMLSCHEMACACHE )
   RECOVER
      aRETORNO[ 'MSG' ] := 'Não foi possível carregar o MSXML para o schema do XML.'
      RETURN aRETORNO
   ENDSEQUENCE

   IF !File( cSchemaFilename )
      aRETORNO[ 'MSG' ] := 'Arquivo do schema não encontrado ' + cSchemaFilename
      RETURN aRETORNO
   ENDIF

   BEGIN SEQUENCE WITH __BreakBlock()
      oSchema:add( 'http://localhost:8080/WsNFe2/lote', cSchemaFilename )
   RECOVER // CATCH oError
      aRETORNO[ 'MSG' ] := 'Falha ' + hb_eol() + ;
         'Error: ' + Transform( oError:GenCode, nil )   + ';' + hb_eol() + ;
         'SubC: ' + Transform( oError:SubCode, nil )    + ';' + hb_eol() + ;
         'OSCode: ' + Transform( oError:OsCode, nil )   + ';' + hb_eol() + ;
         'SubSystem: ' + Transform( oError:SubSystem, nil ) + ';' + hb_eol() + ;
         'Mensangem: ' + oError:Description
      RETURN aRETORNO
   ENDSEQUENCE

   oDOMDoc:Schemas := oSchema
   ParseError := oDOMDoc:validate
   IF ParseError:errorCode <> 0
      aRetorno[ 'nResult' ] := ParseError:errorCode
      aRETORNO[ 'MSG' ] := ParseError:reason
      RETURN aRetorno
   ENDIF
   oDOMDoc := nil
   ParseError := nil
   oSchema := nil
   aRETORNO[ 'XML' ] := ::Xml
   aRETORNO[ 'STATUS' ] := .T.

   RETURN aRETORNO

METHOD Gera_Chave_SHA1() CLASS NFSE

   LOCAL cRET
   LOCAL cCHA := PadL( AllTrim( ::rps_InscricaoMunicipalPrestador ), 8, '0' )
   LOCAL oFuncoes := hbNFeFuncoes()

   cCHA += PadR( AllTrim( ::rps_SerieRPS ), 5, ' ' )
   cCHA += StrZero( ::rps_NumeroRPS, 12 )
   cCHA += Dtos( ::rps_DataEmissaoRPS )
   cCHA += AllTrim( ::rps_Tributacao )
   cCHA += Left( AllTrim( ::rps_SituacaoRPS ), 1 )
   cCHA += IF( AllTrim( Left( ::rps_TipoRecolhimento, 1 ) ) = 'A', 'N', 'S' )

// V10.0.K1608
// cCHA += STRZERO(VAL(STRTRAN(STR((::cab_ValorTotalServicos-::cab_ValorTotalDeducoes)*100),'.')),15) //STRZERO((::cab_ValorTotalServicos-::cab_ValorTotalDeducoes),15)
   cCHA += StrZero( Val( StrTran( Str( Int( ( ::cab_ValorTotalServicos - ::cab_ValorTotalDeducoes ) * 100 ) ), '.' ) ), 15 ) // STRZERO((::cab_ValorTotalServicos-::cab_ValorTotalDeducoes),15)

   cCHA += StrZero( Val( StrTran( Str( ::cab_ValorTotalDeducoes * 100, 15 ), '.' ) ), 15 ) // STRZERO(::cab_ValorTotalDeducoes/100,15)
   cCHA += PadL( AllTrim( ::rps_CodigoAtividade ), 5, '0' )

   IF Len( AllTrim( ::rps_CPFCNPJTomador ) ) == 11
      cCHA += "1" // CPF
   ELSE
      cCHA += "2" // CNPJ
   ENDIF

   cCHA += PadL( AllTrim( ::rps_CPFCNPJTomador ), 14, '0' )

   nHandle := FCreate( "StringParaAssinar.txt" )
   FWrite( nHandle, ::ohbNFe:cSerialCert + Chr( 13 ) + Chr( 10 ) + cCHA )
   FClose( nHandle )
   WRunCMD( "AssinaRPS.EXE" )
   cRET := MemoRead( "StringAssinada.txt" )

   cRET := StrTran( cRET, Chr( 13 ), "" )
   cRET := StrTran( cRET, Chr( 10 ), "" )

   FErase( "StringParaAssinar.txt" )
   FErase( "StringAssinada.txt" )

   RETURN oFuncoes:parseEncode( cRET )

METHOD Gera_Chave_SHA1_Cancelamento() CLASS NFSE

   LOCAL cRET
   LOCAL cCHA := ""
   LOCAL oFuncoes := hbNFeFuncoes()

   cCHA += PadL( AllTrim( ::rps_InscricaoMunicipalPrestador ), 8, '0' )
   cCHA += PadL( AllTrim( Str( ::numero_nota ) ), 12, '0' )

   nHandle := FCreate( "StringParaAssinar.txt" )

   FWrite( nHandle, ::ohbNFe:cSerialCert + Chr( 13 ) + Chr( 10 ) + cCHA )
   FClose( nHandle )
   WRunCMD( "AssinaRPS.EXE" )

   cRET := MemoRead( "StringAssinada.txt" )
   cRET := StrTran( cRET, Chr( 13 ), "" )
   cRET := StrTran( cRET, Chr( 10 ), "" )
   FErase( "StringParaAssinar.txt" )
   FErase( "StringAssinada.txt" )

   RETURN oFuncoes:parseEncode( cRET )

FUNCTION AlteraCaracteres( c, lInverte )

   hb_default( @lInverte, .F. )

   IF lInverte
      c := StrTran( c, "&gt;", ">" )
      c := StrTran( c, "&lt;", "<" )
      c := StrTran( c, "&amp;", "&" )
      c := StrTran( c, "&quot;", '"' )
      c := StrTran( c, "&apos;", "'" )
   ELSE
      c := StrTran( c, ">", "&gt;" )
      c := StrTran( c, "<", "&lt;" )
      c := StrTran( c, "&", "&amp;" )
      c := StrTran( c, '"', "&quot;" )
      c := StrTran( c, "'", "&apos;" )
   ENDIF

   RETURN c

FUNCTION DateXml( dData ) ;       RETURN Transform( Dtos( dData ), "@R 9999-99-99" )

FUNCTION XmlTag( cTag, cValue ) ; RETURN "<" + cTag + ">" + cValue + "<" + cTag + "/>"

// FUNCTION hb_Eol()  ;           RETURN hb_OsNewLine()
// FUNCTION __BreakBlock() ;      RETURN { | e | Break(e) }

CREATE CLASS PMSPClass
   ENDCLASS
